# PrinMusic

PrinMusic is a sandbox-like program to visualize midi files with 3D models using [Three.js](https://threejs.org) and [MIDI.js](https://galactic.ink/midi-js/). Each model's components, such as the number of keys, are generated by a MIDI channel's range, and each model is animated by the data sequence of notes in a MIDI channel.

This program was written by [Drew Shotwell](mailto:drew.shotwell@principia.edu), [Cameron Wood](mailto:cameron.wood@principia.edu), and [Blake Peters](mailto:blake.peters@principia.edu), and funded with the support of the Principia College Computer Science Department under the supervision of [Dr. Clint Staley](mailto:clint.staley@principia.edu).

## Setup

Each instrument model to be added into the scene is its own class, extending the base class `InstrumentModel`, which itself is a subclass of `THREE.Group`. Each InstumentModel subclass constructor must take in the song data, MIDI channel, and an optional parameter for size. Both
In `Main.js`, a song is constructed with an optional parameter containing a list of instruments that override the channels' instruments in the MIDI file.

```javascript
const song = new Song('Popcorn.mid', 120, ['celesta']);
```

Then, for each channel is mapped to a class object (which extends `InstrumentModel`). Any channel not mapped to anything will be defaulted to the already-existent MusicBox.

```javascript
const modMap = {
   'cnl0': MusicBox,
   'cnl1': OtherInstrument,
};
```

As long as these things are set up correctly, any instrument model can be constructed that is paired with a MIDI channel.

## Animation

Each subclass that moves with the music must have a `updateAnimation(time)` method that updates the object's transform in relation to the time (in milliseconds) that has passed. Depending on the type of instrument, there are different ways to animate an object with the MIDI data. In `MusicBox.js`, for example, there are two different cases of animation. The first case, in `MusicBox.CylinderPlayer`, is using the MIDI data to construct a number of objects (in this case, the note nibs) based on the MIDI data. In this case, the MIDI data is mostly utilized in the constructor. For example, here is the creation of a single nib using the MIDI data.

```javascript
const rng = this.song.getRange(this.cnl);
const len = note.end - note.start;
const ridges = Math.trunc(len / 20);
// Make box with multiple x vertices for ridge creation
const nibGmy = new THREE.BoxBufferGeometry(len / 1000, width, 0.1, ridges);
```

The second case, in `MusicBox.Harp`, is the _live animation_ of an object using the MIDI data. While constructor only uses the MIDI range to construct the keys, most of utilization of the data happens in the  `updateAnimation` function. The function checks to see if a certain keys is within the right range or not, then transforms a certain key appropriatly. In this example, nxtTime and curTime are the live animation time frames seperated by a 24th of a second.

```javascript
for (let nte of this.song.notesMap[`cnl${this.cnl}`]) {
   const nteKey = this.keys[nte.note - this.song.getRange(this.cnl).min];
   // If curTime is greater than nxtTime, must be last note
   if (nte.end > curTime && (nte.end < nxtTime || curTime > nxtTime)) {
      this.keyOff(nteKey);
   }
   // If note start and curTime are less than one frame, play first note
   if ((nte.start > curTime || (nte.start < (1000/24) &&
         curTime < (1000/24))) && nte.start < nxtTime) {
      this.keyOn(nteKey);
   }
}
```

## Further details

Consult the `General Documentation.txt` file for further details about how each class works.
